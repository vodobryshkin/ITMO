// Файл с функциями для работы с cистемой счисления Цекендорфа
package main

import (
   "math/big"
)

// Константа для функции closestFibNumber
const FIB_NUM_SIZE int = 100000

// Функция для расчёта последовательности Фиббоначи до n-ого элемента
func calculateFibNumbers(n int) []*big.Int {
   // Создание слайса, в котором будут храниться числа Фиббоначи
   fibNumbers := make([]*big.Int, n + 2)
   // Инициализация первых двух чисел Фиббоначи - 0 и 1
   fibNumbers[0], fibNumbers[1] = big.NewInt(0), big.NewInt(1)
   
   // Расчёт элементов последовательности Фиббоначи
   for i := 2; i < n + 2; i++ {
      fibNumbers[i] = new(big.Int).Set(fibNumbers[i - 2])
      fibNumbers[i].Add(fibNumbers[i], fibNumbers[i - 1])
   }
   
   // Возвращение последовательности без первых двух элементов, т.к. они не используются при 
   // переводе в систему счисления Цекендорфа
   return fibNumbers[2:n + 2]
}

// Функция для нахождения индекса ближайшего меньшего числа Фиббоначи к заданному n
func closestFibIndex(n *big.Int) int {
   // Расчёт последовательности Фиббоначи до 100000 элемента включительно
   fibNumbers := calculateFibNumbers(FIB_NUM_SIZE)

   // Создание двух границ для бинарного поиска, который будет применяться для нахождения
   // ближайшего меньшего числа Фиббоначи к данному n. Нет смысла хранить переменные left и right
   // в переменных типа big.Int, ввиду того, что обычного Int будет вполне достаточно
   left, right := 0, FIB_NUM_SIZE
   
   // Реализация левостороннего бинарного поиска
   for right - left > 1 {
      middle := (left + right) / 2
      
      // Условие, переписанное с учётом специфики типа big.Int (Если fibNumbers[middle] больше n)
      switch fibNumbers[middle].Cmp(n) {
      // Если больше, то код 1, тогда производится ограничение правой границы
      case 1:
         right = middle
      // Если меньше, то код -1; если равно, то код 0; тогда производится ограничение левой границы
      case -1, 0:
         left = middle
      }
   }

   // Т.к. левосторонний бинарный поиск, значит возвращается левая граница, как индекс ближайшего 
   // меньшего числа Фиббоначи к заданному n
   return left
}

// Функция для перевода целой числа из СС Цекендорфа в 10чную систему счисления
func fibToTen(n string) string {
   fibNumbers := calculateFibNumbers(len(n))
   // Конечный результат будет равен сумме всех умножений, значит начальное значение равно нулю
   res := big.NewInt(0)
   
   // Перебираются все элементы с конца ввиду возрастающего расположения элементов в массиве, а
   // так же ввиду алгоритма перевода целой части числа из СС А в СС В
   for i := len(n) - 1; i >= 0; i-- {
      // Перемножение разряда числа и n-ого числа Фиббоначи
      bigR := big.NewInt(int64(n[i]) - 48)
      bigR.Mul(bigR, fibNumbers[i])
      
      // Полученное число складывается с результатом
      res.Add(res, bigR)
   }
   
   return res.String()
}

// Функция для перевода числа из десятеричной СС в СС Цекендорфа
func tenToFib(n string) string {
   // Если число в 10-чной СС равно нулю, то в СС Цекендорфа оно так же будет нулем
   
   // Переменные для получения результата и работы в цикле
   res := ""
   i := 0
   
   // Перевод исходного числа в класс big.Int
   bigIntN := big.NewInt(stringToInt(n))
   // Получение списка чисел Фиббоначи
   fibNumbers := reverseBigIntArray(calculateFibNumbers((closestFibIndex(bigIntN) + 1)))
   
   // Алгоритм перевода числа, используем while ввиду того, что i - не инкремент
   for i < len(fibNumbers) {
      // Вычитание от данного n i-того числа Фиббоначи
      bigIntN.Sub(bigIntN, fibNumbers[i])      
      nullBigInt := big.NewInt(0)
      
      // Сравнение полученной разницы с нулем
      switch bigIntN.Cmp(nullBigInt) {
      case 0, 1: // Если разница больше либо равна нуля, то это число записывается в конечную запись
         res += "10"
         i += 2
      case -1: // Если разница меньше нуля, то возвращаем n значение прошлого шага цикла
         bigIntN.Add(bigIntN, fibNumbers[i])
         res += "0"
         i += 1
      }
   }
   
   // Если число в записи в СС Цекенфорфа оканчивается на 1 (например 4 = 101), то алгоритм запишет
   // его как 1010, значит, для корректной работы программы необходимо обработать этот случай
   if len(res) != len(fibNumbers) {
      // Удаление лишнего нуля на конце числа
      res = res[:len(res) - 1]
   } 

   return res
}

